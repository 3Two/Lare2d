/*****************************************************************************
*
* Copyright (c) 2000 - 2006, The Regents of the University of California
* Produced at the Lawrence Livermore National Laboratory
* All rights reserved.
*
* This file is part of VisIt. For details, see http://www.llnl.gov/visit/. The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or materials provided with the distribution.
*  - Neither the name of the UC/LLNL nor  the names of its contributors may be
*    used to  endorse or  promote products derived from  this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED.  IN  NO  EVENT  SHALL  THE  REGENTS  OF  THE  UNIVERSITY OF
* CALIFORNIA, THE U.S.  DEPARTMENT  OF  ENERGY OR CONTRIBUTORS BE  LIABLE  FOR
* ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                            avtLare2DV2FileFormat.C                           //
// ************************************************************************* //

#include <avtLare2DV2FileFormat.h>

#include <string>

#include <vtkFloatArray.h>
#include <vtkDoubleArray.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUnstructuredGrid.h>
#include <avtDatabaseMetaData.h>

#include <Expression.h>

#include <InvalidVariableException.h>

#include <DebugStream.h>

using     std::string;

vtkDataArray* (avtLare2DV2FileFormat::*read_current)(int) = NULL;

// ****************************************************************************
//  Method: avtLare2DV2 constructor
//
//  Programmer: phsgbd -- generated by xml2avt
//  Creation:   Tue Jul 3 14:02:23 PST 2007
//
// ****************************************************************************

avtLare2DV2FileFormat::avtLare2DV2FileFormat(const char *filename)
    : avtSTSDFileFormat(filename)
{
  if (file.is_open()) file.close();
  file.open(filename);
  if (!file.good()) return;

  int flen;
  file.seekg(0,ios::end);
  flen=file.tellg();
  file.seekg(0,ios::beg);

  char end[10];
  memset(end,0,10);
  int stlen=strlen(filename);
  const char* filenamepoint = filename+stlen-9;
  strncpy(end,filenamepoint,9);
  debug1 << "Full filename " << filename << "\n";
  debug1 << "Recovered tag " << end << "\n";

  sscanf(end,"%i",&this->cycle);
  debug1 << "Cycle number " << this->cycle << "\n";

  file.read((char*)&this->dims,sizeof(int)*2);
  this->dims[0]++;
  this->dims[1]++;
  this->dims[2]=1;
  file.read((char*)&this->sizeoffloat,sizeof(int));
  debug1 << this->sizeoffloat << endl;


  offset=3*sizeof(int)+sizeoffloat+sizeoffloat*(dims[0]+dims[1]);


  if (this->sizeoffloat == 8)
    {
      file.read((char*)&this->time,sizeoffloat);
    }
  else
    {
      float f;
      file.read((char*)&f,sizeoffloat);
      this->time=f;
    }


  debug1 << "Current time is " << this->time << "\n";
  debug1 << "ngrid is " << dims[0] << " x " << dims[1] << "\n";

  this->x=malloc(sizeoffloat*this->dims[0]);
  this->y=malloc(sizeoffloat*this->dims[1]);


  debug1 << "Reading X\n";
  file.read((char*)this->x,sizeoffloat*this->dims[0]);
  debug1 << "Reading Y\n";
  file.read((char*)this->y,sizeoffloat*this->dims[1]);
  debug1 << "Read data, starting \n";

  if (sizeoffloat == 4)
    {
      read_current=&avtLare2DV2FileFormat::read_current_sgl;
    }
  else
    {
      read_current=&avtLare2DV2FileFormat::read_current_dbl;
    }

}


// ****************************************************************************
//  Method: avtLare2DV2FileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: phsgbd -- generated by xml2avt
//  Creation:   Tue Jul 3 14:02:23 PST 2007
//
// ****************************************************************************

void
avtLare2DV2FileFormat::FreeUpResources(void)
{
}


// ****************************************************************************
//  Method: avtLare2DV2FileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: phsgbd -- generated by xml2avt
//  Creation:   Tue Jul 3 14:02:23 PST 2007
//
// ****************************************************************************

void
avtLare2DV2FileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md)
{
  std::string meshname="Mesh";
  avtMeshMetaData *mmd= new avtMeshMetaData;
  mmd->name = meshname;
  mmd->spatialDimension = 2;
  mmd->topologicalDimension = 2;
  mmd->meshType = AVT_RECTILINEAR_MESH;
  mmd->numBlocks=1;
  md->Add(mmd);


    avtCentering cent = AVT_NODECENT;

    AddScalarVarToMetaData(md, "Fluid/Density", meshname, cent);
    AddScalarVarToMetaData(md, "Fluid/Temperature", meshname, cent);
    AddScalarVarToMetaData(md, "Velocity/V_x", meshname, cent);
    AddScalarVarToMetaData(md, "Velocity/V_y", meshname, cent);
    AddScalarVarToMetaData(md, "Velocity/V_z", meshname, cent);
    AddScalarVarToMetaData(md, "Magnetic_Field/B_x", meshname, cent);
    AddScalarVarToMetaData(md, "Magnetic_Field/B_y", meshname, cent);
    AddScalarVarToMetaData(md, "Magnetic_Field/B_z", meshname, cent);
    AddScalarVarToMetaData(md, "Current/J_x",meshname,cent);
    AddScalarVarToMetaData(md, "Current/J_y",meshname,cent);
    AddScalarVarToMetaData(md, "Current/J_z",meshname,cent);


    Expression expr;
    expr.SetName("Planar_Velocity");
      expr.SetDefinition("{<Velocity/V_x>,<Velocity/V_y>}");
    expr.SetType(Expression::VectorMeshVar);
    md->AddExpression(&expr);

    expr.SetName("Planar_Magnetic_Field");
      expr.SetDefinition("{<Magnetic_Field/B_x>,<Magnetic_Field/B_y>}");
    expr.SetType(Expression::VectorMeshVar);
    md->AddExpression(&expr);

    expr.SetName("Velocity/|V|");
    expr.SetDefinition("sqrt(<Velocity/V_x>^2+<Velocity/V_y>^2+<Velocity/V_z>^2)");
    expr.SetType(Expression::ScalarMeshVar);
    md->AddExpression(&expr);

    expr.SetName("Magnetic_Field/|B|");
    expr.SetDefinition("sqrt(<Magnetic_Field/B_x>^2+<Magnetic_Field/B_y>^2+<Magnetic_Field/B_z>^2)");
    expr.SetType(Expression::ScalarMeshVar);
    md->AddExpression(&expr);

    expr.SetName("Fluid/Pressure");
    expr.SetDefinition("<Fluid/Temperature> * <Fluid/Density>");
    expr.SetType(Expression::ScalarMeshVar);
    md->AddExpression(&expr);
       

    expr.SetName("Planar_Current");
    expr.SetDefinition("{<Current/J_x>, <Current/J_y>}");
    expr.SetType(Expression::VectorMeshVar);
    md->AddExpression(&expr);
}


// ****************************************************************************
//  Method: avtLare2DV2FileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: phsgbd -- generated by xml2avt
//  Creation:   Tue Jul 3 14:02:23 PST 2007
//
// ****************************************************************************

vtkDataSet *
avtLare2DV2FileFormat::GetMesh(const char *meshname)
{
      if (!this->x || !this->y) return NULL;
      vtkDataArray *xx = NULL;
      vtkDataArray *yy = NULL;
      vtkDataArray *zz = NULL;

      if (sizeoffloat==4)
	{
	  xx=vtkFloatArray::New();
	  yy=vtkFloatArray::New();
	  zz=vtkFloatArray::New();
	  ((vtkFloatArray*)xx)->SetArray((float*)this->x,this->dims[0],1);
	  ((vtkFloatArray*)yy)->SetArray((float*)this->y,this->dims[1],1);
	  ((vtkFloatArray*)zz)->SetNumberOfTuples(1);
	  ((vtkFloatArray*)zz)->SetComponent(0,0,0.);
	}
      else
	{
	  xx=vtkDoubleArray::New();
	  yy=vtkDoubleArray::New();
	  zz=vtkDoubleArray::New();
	  ((vtkDoubleArray*)xx)->SetArray((double*)this->x,this->dims[0],1);
	  ((vtkDoubleArray*)yy)->SetArray((double*)this->y,this->dims[1],1);
	  ((vtkDoubleArray*)zz)->SetNumberOfTuples(1);
	  ((vtkDoubleArray*)zz)->SetComponent(0,0,0.);
	}
      
      vtkRectilinearGrid *grid = vtkRectilinearGrid::New();

      grid->SetDimensions(this->dims);
      grid->SetXCoordinates(xx);
      grid->SetYCoordinates(yy);
      grid->SetZCoordinates(zz);

      xx->Delete();
      yy->Delete();
      zz->Delete();
      return grid;
}


// ****************************************************************************
//  Method: avtLare2DV2FileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      varname    The name of the variable requested.
//
//  Programmer: phsgbd -- generated by xml2avt
//  Creation:   Tue Jul 3 14:02:23 PST 2007
//
// ****************************************************************************

vtkDataArray *
avtLare2DV2FileFormat::GetVar(const char *varname)
{
  int offset=this->offset;

  if (!this->file.good()) return NULL;

  if (strcmp(varname,"Fluid/Density") == 0)
    offset+=0;
  else if (strcmp(varname,"Fluid/Temperature") == 0)
    offset+=sizeoffloat*(dims[0]*dims[1]);
  else if (strcmp(varname,"Velocity/V_x")==0)
    offset+=2*sizeoffloat*(dims[0]*dims[1]);
  else if (strcmp(varname,"Velocity/V_y")==0)
    offset+=3*sizeoffloat*(dims[0]*dims[1]);
  else if (strcmp(varname,"Velocity/V_z")==0)
    offset+=4*sizeoffloat*(dims[0]*dims[1]);
  else if (strcmp(varname,"Magnetic_Field/B_x")==0)
    offset+=5*sizeoffloat*(dims[0]*dims[1]);
  else if (strcmp(varname,"Magnetic_Field/B_y")==0)
    offset+=6*sizeoffloat*(dims[0]*dims[1]);
  else if (strcmp(varname,"Magnetic_Field/B_z")==0)
    offset+=7*sizeoffloat*(dims[0]*dims[1]);
  else if (strcmp(varname,"Current/J_x")==0)
    return (*this.*read_current)(0);
  else if (strcmp(varname,"Current/J_y")==0)
    return (*this.*read_current)(1);
  else if (strcmp(varname,"Current/J_z")==0)
  return (*this.*read_current)(2);
  else
    EXCEPTION1(InvalidVariableException, varname);

  vtkDataArray *arr= NULL;

  if (this->sizeoffloat==4)
    {
      arr = vtkFloatArray::New();
    }
  else
    {
      arr = vtkDoubleArray::New();
    }
  if (!arr) return NULL;
  arr->SetNumberOfTuples(dims[0]*dims[1]);
  void* data = arr->GetVoidPointer(0);
  if (!data) return NULL;

  file.seekg(offset,ios::beg);
  file.read((char*)data,sizeoffloat*(dims[0]*dims[1]));

  return arr;

}


// ****************************************************************************
//  Method: avtLare2DV2FileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      varname    The name of the variable requested.
//
//  Programmer: phsgbd -- generated by xml2avt
//  Creation:   Tue Jul 3 14:02:23 PST 2007
//
// ****************************************************************************

vtkDataArray *
avtLare2DV2FileFormat::GetVectorVar(const char *varname)
{
  return NULL;
}

// ****************************************************************************
//  Method: avtLareV2FileFormat::read_current
//
//  Purpose:
//      Calculate the current using LARE like differentials
//      Still experimental
//
//
//  Arguments:
//      direction    <0=NULL,0=jx,1=jy,2=jz,>2=NULL
//
//
// ****************************************************************************
vtkDataArray *
avtLare2DV2FileFormat::read_current_sgl(int direction)
{
    if (direction < 0 || direction >2) return NULL;
  long ix,iy;
  long offset;
  float *B_Current,*x,*y;
  x=(float*)this->x;
  y=(float*)this->y;
  vtkDataArray *arr=NULL;
  arr = vtkFloatArray::New();
  if (!arr) return NULL;
  arr->SetNumberOfTuples(dims[0]*dims[1]);
  float* data = (float*)arr->GetVoidPointer(0);
  if (!data) return NULL;
  memset(data,0,sizeoffloat*dims[0]*dims[1]);

  B_Current=(float*)malloc(sizeoffloat*dims[0]*dims[1]);

  switch(direction)
    {
    case 0:
      offset=this->offset+7*sizeoffloat*(dims[0]*dims[1]);
      file.seekg(offset,ios::beg);
      file.read((char*)B_Current,sizeoffloat*(dims[0]*dims[1]));
      for (long i=0;i<dims[0]*dims[1];++i)
	{
	  iTOxy(i,&ix,&iy);
	  //dBz/dy
	  if (range_check(ix,iy))
	  	  data[i]+=(B_Current[xyTOi(ix,iy+1)]-B_Current[i])/(y[iy+1]-y[iy]);
	}
      //Next loop simply moves the current to the cell vertices
      //If speed is crucial, simply rem this out
      for (long i=0;i<dims[0]*dims[1];++i)
	{
	  iTOxy(i,&ix,&iy);
	  //Move to vertices
	  if (range_check(ix,iy))
	  	  {
		    data[i]+=data[xyTOi(ix+1,iy)];
		    data[i]/=2.0;
		  }
	}

	 break;

    case 1:
      offset=this->offset+7*sizeoffloat*(dims[0]*dims[1]);
      file.seekg(offset,ios::beg);
      file.read((char*)B_Current,sizeoffloat*(dims[0]*dims[1]));
      for (long i=0;i<dims[0]*dims[1];++i)
	{
	  iTOxy(i,&ix,&iy);
	  //dBz/dx
	  if (range_check(ix,iy))
	  	  data[i]-=(B_Current[xyTOi(ix+1,iy)]-B_Current[i])/(x[ix+1]-x[ix]);
	}
      //Next loop simply moves the current to the cell vertices
      //If speed is crucial, simply rem this out
      for (long i=0;i<dims[0]*dims[1];++i)
	{
	  iTOxy(i,&ix,&iy);
	  //Move to vertices
	  if (range_check(ix,iy))
	  	  {
		    data[i]+=data[xyTOi(ix,iy+1)];
		    data[i]/=2.0;
		  }
	}

	 break;

    case 2:
      offset=this->offset+5*sizeoffloat*(dims[0]*dims[1]);
      file.seekg(offset,ios::beg);
      file.read((char*)B_Current,sizeoffloat*(dims[0]*dims[1]));
      for (long i=0;i<dims[0]*dims[1];++i)
	{
	  iTOxy(i,&ix,&iy);
	  //dBx/dy
	  if (range_check(ix,iy))
	    data[i]-=(B_Current[xyTOi(ix,iy+1)]-B_Current[i])/(y[iy+1]-y[iy]);

	}
      offset=this->offset+6*sizeoffloat*(dims[0]*dims[1]);
      file.seekg(offset,ios::beg);
      file.read((char*)B_Current,sizeoffloat*(dims[0]*dims[1]));
      for (long i=0;i<dims[0]*dims[1];++i)
	{
	  iTOxy(i,&ix,&iy);
	  //dBy/dx
	  if (range_check(ix,iy))
	  	  data[i]+=(B_Current[xyTOi(ix+1,iy)]-B_Current[i])/(x[ix+1]-x[ix]);
	}
	 break;

    default:
	   break;
    }
  free(B_Current);
  return arr;
}
// ****************************************************************************
vtkDataArray *
avtLare2DV2FileFormat::read_current_dbl(int direction)
{
    if (direction < 0 || direction >2) return NULL;
  long ix,iy;
  long offset;
  double *B_Current,*x,*y;
  x=(double*)this->x;
  y=(double*)this->y;
  vtkDataArray *arr=NULL;
  arr = vtkDoubleArray::New();
  if (!arr) return NULL;
  arr->SetNumberOfTuples(dims[0]*dims[1]);
  double* data = (double*)arr->GetVoidPointer(0);
  if (!data) return NULL;
  memset(data,0,sizeoffloat*dims[0]*dims[1]);

  B_Current=(double*)malloc(sizeoffloat*dims[0]*dims[1]);

  switch(direction)
    {
    case 0:
      offset=this->offset+7*sizeoffloat*(dims[0]*dims[1]);
      file.seekg(offset,ios::beg);
      file.read((char*)B_Current,sizeoffloat*(dims[0]*dims[1]));
      for (long i=0;i<dims[0]*dims[1];++i)
	{
	  iTOxy(i,&ix,&iy);
	  //dBz/dy
	  if (range_check(ix,iy))
	  	  data[i]+=(B_Current[xyTOi(ix,iy+1)]-B_Current[i])/(y[iy+1]-y[iy]);
	}
      //Next loop simply moves the current to the cell vertices
      //If speed is crucial, simply rem this out
      for (long i=0;i<dims[0]*dims[1];++i)
	{
	  iTOxy(i,&ix,&iy);
	  //Move to vertices
	  if (range_check(ix,iy))
	  	  {
		    data[i]+=data[xyTOi(ix+1,iy)];
		    data[i]/=2.0;
		  }
	}

	 break;

    case 1:
      offset=this->offset+7*sizeoffloat*(dims[0]*dims[1]);
      file.seekg(offset,ios::beg);
      file.read((char*)B_Current,sizeoffloat*(dims[0]*dims[1]));
      for (long i=0;i<dims[0]*dims[1];++i)
	{
	  iTOxy(i,&ix,&iy);
	  //dBz/dx
	  if (range_check(ix,iy))
	  	  data[i]-=(B_Current[xyTOi(ix+1,iy)]-B_Current[i])/(x[ix+1]-x[ix]);
	}
      //Next loop simply moves the current to the cell vertices
      //If speed is crucial, simply rem this out
      for (long i=0;i<dims[0]*dims[1];++i)
	{
	  iTOxy(i,&ix,&iy);
	  //Move to vertices
	  if (range_check(ix,iy))
	  	  {
		    data[i]+=data[xyTOi(ix,iy+1)];
		    data[i]/=2.0;
		  }
	}

	 break;

    case 2:
      offset=this->offset+5*sizeoffloat*(dims[0]*dims[1]);
      file.seekg(offset,ios::beg);
      file.read((char*)B_Current,sizeoffloat*(dims[0]*dims[1]));
      for (long i=0;i<dims[0]*dims[1];++i)
	{
	  iTOxy(i,&ix,&iy);
	  //dBx/dy
	  if (range_check(ix,iy))
	    data[i]-=(B_Current[xyTOi(ix,iy+1)]-B_Current[i])/(y[iy+1]-y[iy]);

	}
      offset=this->offset+6*sizeoffloat*(dims[0]*dims[1]);
      file.seekg(offset,ios::beg);
      file.read((char*)B_Current,sizeoffloat*(dims[0]*dims[1]));
      for (long i=0;i<dims[0]*dims[1];++i)
	{
	  iTOxy(i,&ix,&iy);
	  //dBy/dx
	  if (range_check(ix,iy))
	  	  data[i]+=(B_Current[xyTOi(ix+1,iy)]-B_Current[i])/(x[ix+1]-x[ix]);
	}
       
	 break;

    default:
	   break;
    }
  free(B_Current);
  return arr;
}
// ****************************************************************************
long avtLare2DV2FileFormat::xyTOi(long ix, long iy)
{
  int i;
  i=iy*dims[0];
  i+=ix;

  return i;
}
// ****************************************************************************
void avtLare2DV2FileFormat::iTOxy(long i,long *ix, long *iy)
{
*iy=i/(dims[0]);
*ix=i-*iy*dims[0];
}
// ****************************************************************************
bool avtLare2DV2FileFormat::range_check(int ix,int iy)
{
  if (ix <0 || ix >= dims[0]-1) return false;
  if (iy <0 || iy >= dims[1]-1) return false;
  return true;
}
